name: Deploy to Droplet

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    # environment: prod  # <-- use apenas se seus segredos estão num Environment chamado "prod"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Materialize secrets into env (without exposing values)
        run: |
          {
            echo "DROPLET_HOST=${{ secrets.DROPLET_HOST }}"
            echo "DROPLET_USER=${{ secrets.DROPLET_USER }}"
            echo "SSH_PRIVATE_KEY_PRESENT=$([ -n '${{ secrets.SSH_PRIVATE_KEY }}' ] && echo 1 || echo 0)"
            echo "DROPLET_APP_DIR=${{ secrets.DROPLET_APP_DIR }}"
          } >> "$GITHUB_ENV"

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          missing=0

          for v in DROPLET_HOST DROPLET_USER DROPLET_APP_DIR; do
            val="${!v:-}"
            if [[ -z "$val" ]]; then
              echo "::error title=Missing secret::$v is EMPTY (check Secrets scope/name)"
              missing=1
            else
              echo "::notice title=Secret present::$v length=${#val}"
            fi
          done

          if [[ "${SSH_PRIVATE_KEY_PRESENT:-0}" != "1" ]]; then
            echo "::error title=Missing secret::SSH_PRIVATE_KEY is EMPTY"
            missing=1
          else
            echo "::notice title=Secret present::SSH_PRIVATE_KEY is set"
          fi

          [[ "$missing" -eq 0 ]]

      - name: Write private key to file
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.ssh"
          chmod 700 "$HOME/.ssh"

          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$HOME/.ssh/id_key"
          sed -i 's/\r$//' "$HOME/.ssh/id_key"
          chmod 600 "$HOME/.ssh/id_key"

          echo "SSH_KEY_PATH=$HOME/.ssh/id_key" >> "$GITHUB_ENV"

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key_path: ${{ env.SSH_KEY_PATH }}
          script_stop: true
          envs: APP_DIR
        script: |
          set -eu
          REPO_URL=${{ github.server_url }}/${{ github.repository }}.git
          TARGET_DIR="${APP_DIR:-$HOME/personal-leveling}"

          mkdir -p "$TARGET_DIR"
          if [ ! -d "$TARGET_DIR/.git" ]; then
            git clone "$REPO_URL" "$TARGET_DIR"
          fi
          cd "$TARGET_DIR"
          git fetch --all --prune
          git reset --hard origin/main

          echo "[INFO] Docker versions on remote:"
          (docker --version && docker compose version) 2>&1 || true

          # -------- bloco robusto de detecção --------
          USER_NAME="$(id -un)"
          use_sg=0
          if docker info >/dev/null 2>&1; then
            echo "[INFO] docker funciona direto."
            DOCKER="docker"
          else
            if command -v sg >/dev/null 2>&1 && sg docker -c 'docker info' >/dev/null 2>&1; then
              echo "[INFO] Usando 'sg docker -c' (sessão não herdou grupo)."
              use_sg=1
            elif sudo -n docker info >/dev/null 2>&1; then
              echo "[INFO] Usando 'sudo -n docker'."
              DOCKER="sudo -n docker"
            else
              echo "[ERROR] Sem permissão para usar docker."
              echo "Diag:"
              echo "  whoami: $(whoami)"
              echo "  groups: $(id -nG || true)"
              echo "  docker.sock: $(ls -l /var/run/docker.sock || true)"
              echo "  getent group docker: $(getent group docker || true)"
              echo "Correções:"
              echo "  sudo usermod -aG docker ${USER_NAME} && sudo loginctl terminate-user ${USER_NAME}"
              echo "  # ou NOPASSWD p/ docker: echo \"${USER_NAME} ALL=(ALL) NOPASSWD: /usr/bin/docker\" | sudo tee /etc/sudoers.d/90-${USER_NAME}-docker && sudo visudo -cf /etc/sudoers.d/90-${USER_NAME}-docker"
              exit 1
            fi
          fi

          run_docker() {
            if [ "$use_sg" -eq 1 ]; then
              sg docker -c "docker $*"
            else
              $DOCKER "$@"
            fi
          }
          # -------------------------------------------

          export DOCKER_BUILDKIT=1
          export COMPOSE_DOCKER_CLI_BUILD=1
          run_docker compose -f docker-compose.yml pull postgres web || true
          run_docker compose -f docker-compose.yml build --no-cache web
          run_docker compose -f docker-compose.yml up -d postgres web
          run_docker compose -f docker-compose.yml ps
          echo "[INFO] Deploy finished."
