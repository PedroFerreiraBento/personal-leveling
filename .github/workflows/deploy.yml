name: Deploy to Droplet

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    # environment: prod  # <-- use apenas se seus segredos estão num Environment chamado "prod"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Materialize secrets into env (without exposing values)
        # Coloca os secrets em variáveis do job (GITHUB_ENV) para checks/forward
        run: |
          {
            echo "DROPLET_HOST=${{ secrets.DROPLET_HOST }}"
            echo "DROPLET_USER=${{ secrets.DROPLET_USER }}"
            echo "SSH_PRIVATE_KEY_PRESENT=$([ -n '${{ secrets.SSH_PRIVATE_KEY }}' ] && echo 1 || echo 0)"
            echo "DROPLET_APP_DIR=${{ secrets.DROPLET_APP_DIR }}"
            echo "SSH_PASSPHRASE_PRESENT=$([ -n '${{ secrets.SSH_PASSPHRASE }}' ] && echo 1 || echo 0)"
          } >> "$GITHUB_ENV"

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          missing=0

          # checagens por comprimento (sem vazar valores)
          for v in DROPLET_HOST DROPLET_USER DROPLET_APP_DIR; do
            val="${!v:-}"
            if [[ -z "$val" ]]; then
              echo "::error title=Missing secret::$v is EMPTY (check Secrets scope/name)"
              missing=1
            else
              echo "::notice title=Secret present::$v length=${#val}"
            fi
          done

          if [[ "${SSH_PRIVATE_KEY_PRESENT:-0}" != "1" ]]; then
            echo "::error title=Missing secret::SSH_PRIVATE_KEY is EMPTY"
            missing=1
          else
            echo "::notice title=Secret present::SSH_PRIVATE_KEY is set"
          fi

          if [[ "${SSH_PASSPHRASE_PRESENT:-0}" != "1" ]]; then
            echo "::notice::SSH_PASSPHRASE not provided (ok if your key has no passphrase)."
          fi

          [[ "$missing" -eq 0 ]]

      - name: Write private key to file
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.ssh"
          chmod 700 "$HOME/.ssh"

          # grava o secret com quebras de linha preservadas
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$HOME/.ssh/id_key"

          # normaliza quebras de linha Windows, se houver
          sed -i 's/\r$//' "$HOME/.ssh/id_key"
          chmod 600 "$HOME/.ssh/id_key"

          echo "SSH_KEY_PATH=$HOME/.ssh/id_key" >> "$GITHUB_ENV"

      - name: Deploy over SSH (supports passphrase)
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key_path: ${{ env.SSH_KEY_PATH }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          script_stop: true
          # Se quiser reenviar APP_DIR como env para o host, inclua em envs e defina abaixo em `env:`
          envs: APP_DIR
          script: |
            set -euo pipefail
            echo "[REMOTE] APP_DIR on remote: ${APP_DIR:-<empty>}"

            REPO_URL=${{ github.server_url }}/${{ github.repository }}.git

            # Preferência: APP_DIR vindo do job; se vazio, usa fallback no HOME do remoto
            if [[ -n "${APP_DIR:-}" ]]; then
              TARGET_DIR="$APP_DIR"
            else
              echo "[WARN] APP_DIR empty; defaulting to \$HOME/personal-leveling"
              TARGET_DIR="$HOME/personal-leveling"
            fi

            echo "[REMOTE] Using dir: $TARGET_DIR"
            if [[ ! -d "$TARGET_DIR/.git" ]]; then
              mkdir -p "$TARGET_DIR"
              git clone "$REPO_URL" "$TARGET_DIR"
            fi

            cd "$TARGET_DIR"

            echo "[INFO] Docker versions on remote:"
            (docker --version && docker compose version) 2>&1 || true

            if ! docker info >/dev/null 2>&1; then
              echo "[INFO] docker requires sudo. Checking passwordless sudo..."
              if sudo -n true 2>/dev/null; then
                DOCKER="sudo -n docker"
              else
                echo "[ERROR] Configure passwordless sudo for docker or add user to docker group."
                exit 1
              fi
            else
              DOCKER="docker"
            fi

            git fetch --all --prune
            git reset --hard origin/main

            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            COMPOSE="$DOCKER compose -f docker-compose.yml"

            echo "[INFO] Pull images if available..."
            $COMPOSE pull postgres web || true

            echo "[INFO] Build web..."
            $COMPOSE build --no-cache web

            echo "[INFO] Up services..."
            $COMPOSE up -d postgres web

            $COMPOSE ps
            echo "[INFO] Deploy finished."

        env:
          # APP_DIR é seguro reenviar como env; vem do secret mas não aparece em logs
          APP_DIR: ${{ env.DROPLET_APP_DIR }}
