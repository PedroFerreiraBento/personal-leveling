name: Deploy to Droplet
# note: this comment forces a content change to ensure LF-normalized workflow on runners

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Materialize secrets into env (without exposing values)
        run: |
          {
            echo "DROPLET_HOST=${{ secrets.DROPLET_HOST }}"
            echo "DROPLET_USER=${{ secrets.DROPLET_USER }}"
            echo "DROPLET_APP_DIR=${{ secrets.DROPLET_APP_DIR }}"
            echo "SSH_PRIVATE_KEY_PRESENT=$([ -n '${{ secrets.SSH_PRIVATE_KEY }}' ] && echo 1 || echo 0)"
          } >> "$GITHUB_ENV"

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          missing=0

          for v in DROPLET_HOST DROPLET_USER DROPLET_APP_DIR; do
            val="${!v:-}"
            if [[ -z "$val" ]]; then
              echo "::error title=Missing secret::$v is EMPTY (check Secrets scope/name)"
              missing=1
            else
              echo "::notice title=Secret present::$v length=${#val}"
            fi
          done

          if [[ "${SSH_PRIVATE_KEY_PRESENT:-0}" != "1" ]]; then
            echo "::error title=Missing secret::SSH_PRIVATE_KEY is EMPTY"
            missing=1
          else
            echo "::notice title=Secret present::SSH_PRIVATE_KEY is set"
          fi

          [[ "$missing" -eq 0 ]]

      - name: Test SSH connectivity
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            echo "[TEST] Connected to $(hostname)"
            echo "[TEST] whoami: $(whoami)"
            echo "[TEST] uptime: $(uptime)"
            echo "[TEST] pwd: $(pwd)"
            echo "[TEST] Home listing:"
            ls -la ~ || true

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          debug: true
          envs: DROPLET_APP_DIR
          script: |
            # POSIX-friendly
            set -eu
            set -x

            REPO_URL="${{ github.server_url }}/${{ github.repository }}.git"
            TARGET_DIR="${DROPLET_APP_DIR:-$HOME/personal-leveling}"

            echo "[INFO] TARGET_DIR=$TARGET_DIR"
            mkdir -p "$TARGET_DIR"

            if [ ! -d "$TARGET_DIR/.git" ]; then
              echo "[INFO] Clonando repo em $TARGET_DIR"
              git clone "$REPO_URL" "$TARGET_DIR"
            fi

            cd "$TARGET_DIR"
            echo "[INFO] Configurando sparse-checkout para excluir data/postgres…"
            git config core.sparseCheckout true || true
            # Usa modo não-cone para permitir exclusões diretas
            mkdir -p .git/info
            {
              echo "/*"
              echo "!/data/postgres/**"
            } > .git/info/sparse-checkout

            echo "[INFO] Atualizando repo"
            git fetch --all --prune
            git reset --hard origin/main

            echo "[INFO] Docker versions on remote:"
            (docker --version && docker compose version) 2>&1 || true
            echo "[INFO] whoami: $(whoami)"
            echo "[INFO] groups: $(id -nG || true)"
            ls -l /var/run/docker.sock || true

            echo "[INFO] Selecting docker mode..."
            DOCKER="docker"
            if docker info >/dev/null 2>&1; then
              echo "[INFO] Using direct docker"
            elif command -v sg >/dev/null 2>&1 && sg docker -c "docker info" >/dev/null 2>&1; then
              DOCKER="sg docker -c docker"
              echo "[INFO] Using sg docker"; sg docker -c 'id -nG' || true
            elif sudo -n docker info >/dev/null 2>&1; then
              DOCKER="sudo -n docker"
              echo "[INFO] Using sudo -n docker"
            else
              echo "[ERROR] Cannot run docker. Add user to 'docker' group or configure sudo NOPASSWD."
              exit 1
            fi

            [ -f docker-compose.yml ] || { echo "[ERROR] docker-compose.yml não encontrado em $TARGET_DIR"; exit 1; }

            # Pré-checagens comuns de YAML (Windows CRLF, TABs, ausência de 'services:')
            echo "[INFO] Normalizando finais de linha (CRLF -> LF) se houver..."
            sed -i 's/\r$//' docker-compose.yml || true

            echo "[INFO] Checando TABs (YAML exige espaços):"
            if grep -n "$(printf '\t')" docker-compose.yml >/dev/null 2>&1; then
              echo "[ERROR] Há TABs no docker-compose.yml. Substitua por espaços. Linhas:"
              grep -n "$(printf '\t')" docker-compose.yml || true
              echo "------ Início do arquivo (1..120) ------"
              nl -ba docker-compose.yml | sed -n '1,120p'
              exit 1
            fi

            echo "[INFO] Heads-up: primeiras 40 linhas do compose:"
            nl -ba docker-compose.yml | sed -n '1,40p' || true

            echo "[INFO] Validando sintaxe (sem interpolação)…"
            # Mostra erro real do parser do Compose
            if ! ${DOCKER} compose -f docker-compose.yml config --no-interpolate; then
              echo "[ERROR] 'docker compose config --no-interpolate' falhou."
              echo "Causas comuns:"
              echo " - Indentação errada / TABs"
              echo " - Chave raiz 'services:' ausente"
              echo " - Nível errado (ex.: 'build', 'image', 'ports' fora de 'services.<svc>')"
              echo " - YAML inválido (dois pontos, aspas, vírgulas, etc.)"
              echo "------ Preview do arquivo (1..200) ------"
              nl -ba docker-compose.yml | sed -n '1,200p'
              exit 1
            fi

            # Seleciona arquivo de env: prefere .env.production; fallback .env
            COMPOSE_ENV_ARG=""
            if [ -f .env.production ]; then
              echo "[INFO] Usando .env.production para docker compose (--env-file)"
              sed -i 's/\r$//' .env.production || true
              COMPOSE_ENV_ARG="--env-file .env.production"
              echo "[INFO] Chaves presentes em .env.production:"
              sed -n 's/^\([A-Za-z_][A-Za-z0-9_]*\)=.*/  - \1/p' .env.production | sort | uniq | sed 's/^/    /'
            elif [ -f .env ]; then
              echo "[INFO] Usando .env para docker compose (--env-file)"
              sed -i 's/\r$//' .env || true
              COMPOSE_ENV_ARG="--env-file .env"
              echo "[INFO] Chaves presentes em .env:"
              sed -n 's/^\([A-Za-z_][A-Za-z0-9_]*\)=.*/  - \1/p' .env | sort | uniq | sed 's/^/    /'
            else
              echo "[WARN] Nenhum arquivo .env(.production) encontrado; compose dependerá do ambiente do shell."
            fi

            echo "[INFO] Validando com interpolação (se .env existir)…"
            if ! ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml config; then
              echo "[ERROR] 'docker compose config' falhou com interpolação."
              echo "Provável variável ausente. Reveja .env/ambiente e docker-compose.yml."
              exit 1
            fi

            echo "[INFO] Pull/build…"
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml pull postgres api web caddy || true
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml build api web

            echo "[INFO] Starting Postgres only…"
            # Resolve potential name conflict from a previous container not managed by current compose project
            if ${DOCKER} ps -a --format '{{.Names}}' | grep -wq personal-postgres; then
              echo "[WARN] Found existing container named 'personal-postgres'. Removing to avoid conflict…"
              ${DOCKER} rm -f personal-postgres || true
            fi
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml up -d postgres

            echo "[INFO] Waiting for Postgres to be ready…"
            # Readiness: check if server accepts connections (no env var expansion needed)
            for i in $(seq 1 60); do
              if ${DOCKER} compose -f docker-compose.yml exec -T postgres bash -lc 'pg_isready -h 127.0.0.1 -p 5432 -q'; then
                echo "[INFO] Postgres is ready"
                break
              fi
              echo "[INFO] Waiting ($i/60)…"; sleep 2
              if [ "$i" = "60" ]; then echo "[ERROR] Postgres not ready after timeout"; exit 1; fi
            done

            echo "[INFO] Running DB migrations in api service…"
            # Use a one-off run to ensure a clean process and proper exit code
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml run --rm api npm run migrate

            echo "[INFO] Ensuring default admin user by updating bootstrap user…"
            # Load APP_ADMIN_* into shell if env-file exists (without echoing values)
            if [ -f .env.production ]; then
              set +x
              set -a; . ./.env.production; set +a
              set -x
            elif [ -f .env ]; then
              set +x
              set -a; . ./.env; set +a
              set -x
            fi

            # Only proceed if APP_ADMIN_EMAIL and APP_ADMIN_PASSWORD are set
            if [ -n "${APP_ADMIN_EMAIL:-}" ] && [ -n "${APP_ADMIN_PASSWORD:-}" ] && [ -n "${PGUSER:-}" ] && [ -n "${PGDATABASE:-}" ]; then
              BOOTSTRAP_COUNT=$(${DOCKER} compose -f docker-compose.yml exec -T postgres bash -lc "psql -U '${PGUSER:-postgres}' -d '${PGDATABASE:-postgres}' -tAc 'SELECT COUNT(*) FROM users WHERE id = md5(''bootstrap_user_v1'') OR email = ''bootstrap@local'';'" | tr -d '\r' | tr -d ' ')
              echo "[INFO] bootstrap user present: ${BOOTSTRAP_COUNT:-<unknown>}"
              if [ -z "${BOOTSTRAP_COUNT}" ]; then
                echo "[WARN] Could not determine bootstrap user presence (psql error). Skipping admin update."
              elif [ "${BOOTSTRAP_COUNT}" != "0" ]; then
                echo "[INFO] Updating bootstrap user to configured admin credentials"
                # Prevent leaking secrets to logs
                set +x
                ADMIN_EMAIL_LC=$(printf '%s' "$APP_ADMIN_EMAIL" | tr '[:upper:]' '[:lower:]')
                ADMIN_HASH=$(printf '%s' "$APP_ADMIN_PASSWORD" | base64 | tr -d '\n')
                # Use psql -v variables to avoid complex shell quoting
                ${DOCKER} compose -f docker-compose.yml exec -T postgres bash -lc "psql -U '${PGUSER:-postgres}' -d '${PGDATABASE:-postgres}' -v ON_ERROR_STOP=1 -v new_email='"'"'$ADMIN_EMAIL_LC'"'"' -v new_hash='"'"'$ADMIN_HASH'"'"' -c 'UPDATE users SET email = :'"'"'new_email'"'"', password_hash = :'"'"'new_hash'"'"' WHERE id = md5(''bootstrap_user_v1'') OR email = ''bootstrap@local'';'"
                # Re-enable xtrace after sensitive section
                set -x
              else
                echo "[INFO] No bootstrap user found; skipping admin update"
              fi
            else
              echo "[WARN] APP_ADMIN_EMAIL/APP_ADMIN_PASSWORD/PGUSER/PGDATABASE not set; skipping admin bootstrap"
            fi

            echo "[INFO] Cleaning existing api/web/caddy containers (no volumes will be removed)…"
            # Try removing with compose first (does not touch named volumes unless -v)
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml rm -f api web caddy || true
            # Also remove by explicit container names if they linger from previous runs
            for n in personal-api personal-web personal-caddy; do
              if ${DOCKER} ps -a --format '{{.Names}}' | grep -wq "$n"; then
                echo "[WARN] Removing lingering container '$n' to avoid name conflicts…"
                ${DOCKER} rm -f "$n" || true
              fi
            done

            echo "[INFO] Starting/Updating remaining services…"
            ${DOCKER} compose $COMPOSE_ENV_ARG -f docker-compose.yml up -d api web caddy
            ${DOCKER} compose -f docker-compose.yml ps

            echo "[INFO] Deploy finished."
