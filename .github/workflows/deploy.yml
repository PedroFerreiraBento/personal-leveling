name: Deploy to Droplet

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Materialize secrets into env (without exposing values)
        run: |
          {
            echo "DROPLET_HOST=${{ secrets.DROPLET_HOST }}"
            echo "DROPLET_USER=${{ secrets.DROPLET_USER }}"
            echo "DROPLET_APP_DIR=${{ secrets.DROPLET_APP_DIR }}"
            echo "SSH_PRIVATE_KEY_PRESENT=$([ -n '${{ secrets.SSH_PRIVATE_KEY }}' ] && echo 1 || echo 0)"
          } >> "$GITHUB_ENV"

      - name: Validate required secrets
        shell: bash
        run: |
          set -euo pipefail
          missing=0

          for v in DROPLET_HOST DROPLET_USER DROPLET_APP_DIR; do
            val="${!v:-}"
            if [[ -z "$val" ]]; then
              echo "::error title=Missing secret::$v is EMPTY (check Secrets scope/name)"
              missing=1
            else
              echo "::notice title=Secret present::$v length=${#val}"
            fi
          done

          if [[ "${SSH_PRIVATE_KEY_PRESENT:-0}" != "1" ]]; then
            echo "::error title=Missing secret::SSH_PRIVATE_KEY is EMPTY"
            missing=1
          else
            echo "::notice title=Secret present::SSH_PRIVATE_KEY is set"
          fi

          [[ "$missing" -eq 0 ]]

      - name: Test SSH connectivity
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            echo "[TEST] Connected to $(hostname)"
            echo "[TEST] whoami: $(whoami)"
            echo "[TEST] uptime: $(uptime)"
            echo "[TEST] pwd: $(pwd)"
            echo "[TEST] Home listing:"
            ls -la ~ || true

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.DROPLET_HOST }}
          username: ${{ env.DROPLET_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          debug: true
          envs: DROPLET_APP_DIR
          script: |
            set -euxo pipefail

            REPO_URL="${{ github.server_url }}/${{ github.repository }}.git"
            TARGET_DIR="${DROPLET_APP_DIR:-$HOME/personal-leveling}"

            echo "[INFO] TARGET_DIR=$TARGET_DIR"
            mkdir -p "$TARGET_DIR"

            if [ ! -d "$TARGET_DIR/.git" ]; then
              echo "[INFO] Clonando repo em $TARGET_DIR"
              git clone "$REPO_URL" "$TARGET_DIR"
            fi

            cd "$TARGET_DIR"
            echo "[INFO] Atualizando repo"
            git fetch --all --prune
            git reset --hard origin/main

            echo "[INFO] Docker versions on remote:"
            (docker --version && docker compose version) 2>&1 || true

            echo "[INFO] whoami: $(whoami)"
            echo "[INFO] groups: $(id -nG || true)"
            ls -l /var/run/docker.sock || true

            echo "[INFO] Selecting docker invoker..."
            DOCKER_MODE=""
            if docker info >/dev/null 2>&1; then
              DOCKER_MODE="direct"; echo "[INFO] Using direct docker"
            elif command -v sg >/dev/null 2>&1 && sg docker -c "docker info" >/dev/null 2>&1; then
              DOCKER_MODE="sg"; echo "[INFO] Using sg docker"; sg docker -c 'id -nG' || true
            elif sudo -n docker info >/dev/null 2>&1; then
              DOCKER_MODE="sudo"; echo "[INFO] Using sudo -n docker"
            else
              echo "[ERROR] Cannot run docker. Add user to 'docker' group and re-login, or configure sudo NOPASSWD for docker."
              exit 1
            fi

            run_compose() {
              if [ "$DOCKER_MODE" = "sg" ]; then
                sg docker -c "docker compose $*"
              elif [ "$DOCKER_MODE" = "sudo" ]; then
                sudo -n docker compose "$@"
              else
                docker compose "$@"
              fi
            }

            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            # Compose env-file handling
            if [ -f .env ]; then
              echo "[INFO] .env found at $TARGET_DIR/.env"
              echo "[INFO] .env keys:"
              # print only variable names, not values
              sed -n 's/^\([A-Za-z_][A-Za-z0-9_]*\)=.*/  - \1/p' .env | sort | uniq | sed 's/^/    /'
              COMPOSE_ENV_FILE=(--env-file .env)
            else
              echo "[WARN] .env not found at $TARGET_DIR/.env. Compose will rely on current environment."
              COMPOSE_ENV_FILE=()
            fi

            if [ ! -f docker-compose.yml ]; then
              echo "[ERROR] docker-compose.yml não encontrado em $TARGET_DIR"
              exit 1
            fi

            # Validate required environment variables before using compose
            echo "[INFO] Validando variáveis de ambiente necessárias…"
            # Source .env to populate the environment for checks, but never print values
            if [ -f .env ]; then
              set +o xtrace
              set -a
              . ./.env
              set +a
              set -o xtrace
            fi
            # Turn off xtrace to avoid echoing sensitive values during checks
            set +o xtrace
            missing_env=0
            for v in FRONTEND_URL PGDATABASE PGPASSWORD PGUSER PUBLIC_API_URL SITE_DOMAIN; do
              val="${!v-}"
              case "$val" in
                "")
                  echo "[ERROR] Variável obrigatória ausente ou vazia: $v (defina em .env ou no ambiente)"
                  missing_env=1
                  ;;
                *)
                  echo "[OK] $v presente"
                  ;;
              esac
            done
            # Re-enable xtrace for subsequent steps
            set -o xtrace
            if [ "$missing_env" -ne 0 ]; then
              echo "[ERROR] Falta variável(ais) obrigatória(s). Abortando antes do docker compose."
              exit 1
            fi

            echo "[INFO] Validando compose…"
            echo "[INFO] docker compose config (with interpolation)"
            # Avoid appleboy script_stop from aborting on non-zero here; capture rc safely
            CONFIG_RC=0
            { run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml config; CONFIG_RC=$?; } || true
            if [ "$CONFIG_RC" -ne 0 ]; then
              echo "[WARN] docker compose config falhou. Tentando sem interpolação para isolar erro de variáveis…"
              NOINT_RC=0
              { run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml config --no-interpolate; NOINT_RC=$?; } || true
              if [ "$NOINT_RC" -ne 0 ]; then
                echo "[ERROR] docker compose config --no-interpolate também falhou. Saída acima."
                exit 1
              fi
            fi

            echo "[INFO] Pulando pull silencioso (se falhar veremos o erro):"
            # Se você usa imagens privadas, esse comando vai denunciar falta de login
            run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml pull postgres web || true

            echo "[INFO] Buildando (com logs verbosos)…"
            # Remova --no-cache se não quiser rebuild completo
            run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml build web || { 
              echo "[ERROR] Build do serviço 'web' falhou. Logs recentes do build (se houver):"; 
              exit 1; 
            }

            echo "[INFO] Subindo containers…"
            run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml up -d postgres web || {
              echo "[ERROR] Falha ao subir containers. Mostrando logs recentes:";
              run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml ps || true
              run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml logs --no-color --tail=200 postgres || true
              run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml logs --no-color --tail=200 web || true
              exit 1
            }

            echo "[INFO] Estado final:"
            run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml ps
            echo "[INFO] Últimas 100 linhas dos logs do 'web':"
            run_compose "${COMPOSE_ENV_FILE[@]}" -f docker-compose.yml logs --no-color --tail=100 web || true

            echo "[INFO] Deploy finished."
